## 大家都知道js的数据类型分为了基本类型和引用类型，
- 基本类型：**number**，**string**,**boolean**,**null**,**undefined**
- 引用类型：**object**(Array,Function,Date,Regexp,Error)
## 但是实际上我们可能在和其他工种的语言合作的时候会发现，他们嘴里会说出**字典**，**列表**，**集合**等一些数据类型。每中语言有不同的数据类型，现在ES6也紧跟上来了

## 下面我介绍ES6中下新增的数据结构：
# Set
  Set是一个无序不重复元素的集合（想想高中数学学的集合的概念）对象。他是无序的数组，且该数组中没有重复项。
所以正由于他的这两个特性，我想到了这些：
 - 可以利用这个特性做数组去重
 - 因为是无序的所以不能通过**索引**来取集合中的元素 Ps:那要怎样取值呢，往下看

在创建集合对象时我们得使用new关键字来创建，同样可以把一个数组作为参数传进集合对象
```
 var a = new Set();
 var b = new Set([1,2,3]);
```
下面我们来看一下**Set**的 **API**
```
1. set.add(value)       为集合添加元素
2. set.clear()          清空集合对象
3. set.delete(value)    删除集合对象值为value的元素 
4. set.forEach(callbackFn[,context])  和数组的使用方法一样
5. set.has(value)   检查集合内是否有值为value的元素，并返回布尔值,很明显这个方法比数组对象的**indexOf**方法直观多了
6. set.values()     返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值
7. set.keys()       与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。
8. set.size         返回返回Set对象的值的个数
```
注：使用下面的方法可以快速的实现数组去重
```
var arr=[1,1,2,1,2];
arr=[...new Set(arr)];
// 解析赋值还没看到，等以后再说吧，这是在mdn上看到的
```
# WeakSet
WeakSet 是升级版的Set对象，是为了合理运用内存来设计的
与Set对象的差别大概如下:
   1.  WeakSet 不能包含值类型元素，否则会抛出一个TypeError
   2.  WeakSet 不能包含**无引用**的对象,否则会自动清除出集合
   3.  WeakSet 无法被探知其大小，也无法被探知其中所包含的元素
> Weak版本的数据类型是无法包含**无引用**的元素的，一旦数据结构内的任意元素的引用被全部解除
该元素便会被移除出当前所在的数据结构

# Map
## **Map**对象是简单的键/值映射
> 在创建映射对象时，可以直接用new关键字创建，或者可以将一个二元数组（键值对）传入到构建函数中，
其中每一个键值对都会加入到该映射对象中。该数组内的元素会以数组顺序进行处理，如果存在相同的键，则会
按照先进先出的原则，以该键最后一个处理的对应的值为最终值。

### 下面我们来看下map的方法
```javascript
map.set(key,value)  添加键值对到映射中
map.get(key)        获取映射中某一个键的对应值
map.delete(key)     将某一键值对移出映射
map.clear()         清空映射中的所有键值对
map.entries()       返回一个以二元数组(键值对)作为元素的数组
map.has(key)        检查映射中是否包含某一键值对
map.keys()          返回一个以当前映射中所有键作为元素的可迭代对象
map.values()        返回一个以当前映射中所有值作为元素的可迭代对象
map.size            映射中键值对的数量
```
### 映射对象与Object的区别
 ### **map**对象可以以任意对象作为键，也可以很方便地获取键值对的数量。然而这些对于普通的**Object**对象是不可以的，注意。Object对象是没有length属性的
# WeakMap
WeakMap和WeakSet队形很类似，只不过WeakMap的键会检查变量引用，只要其中任意一个引用全被解除，该键值对就会被删除



待解决知识
- 关联数组(键值对)
