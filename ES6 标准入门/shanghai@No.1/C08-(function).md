#8.函数的扩展
###函数参数的默认值
 * 可以与解构赋值默认值结合使用
 * 定义了默认值的参数一般是函数的尾参数
 * 定义了默认值后，函数的length属性将返回没有指定默认值的参数个数
 * 作用域
 	* 如果参数默认值是一个变量，则该变量所在的作用域先是当前函数的作用域，然后才是全局作用域
 	* 如果参数的默认值是一个函数B，则函数B的作用域是全局作用域

###rest参数
以“···变量名”的形式，将函数的多余参数放入一个名为变量名的数组中。
 * rest参数只能作为函数的最后一个参数
 * 函数的length属性不包括rest参数
 
###扩展运算符
相当于rest参数的逆运算，将一个数值转为用逗号分隔的参数序列。
 * 可以替代数组的apply方法
 * 可以用来合并数组
 * 与解构赋值结合可以用来生成数组
 * 使函数可以返回多个值
 * 可用来将字符串和类数组的对象转为数组
 
###name属性
函数的name属性返回该函数的函数名。

###箭头函数
ES6可以用箭头（=>）定义函数。

|箭头左边|箭头右边|
| ------- | ------- |
|用圆括号包裹参数|用大括号包裹多余一行的代码|
|一个参数可以省略圆括号|一行代码可以省略大括号|

需要注意的地方：
 * 箭头函数体内没有自己的this，调用的是定义时所在对象的this
 * 不可以当作构造函数，也就是不能使用new 命令
 * 不可以使用arguments对象，可以使用rest参数代替
 * 不可以使用yield命令，因此箭头函数不能用作Generator函数
 
### 函数绑定
形式：对象::函数
将左边的对象作为上下文环境（this）绑定到右边的函数上

###尾调用优化

 * 尾调用：某个函数的最后一步是调用另一个函数
 * 调用帧：函数调用会在内存形成以个“调用记录”，用来保存调用位置和内部变量等信息。
 * 调用栈：所有的调用帧形成以个调用栈。

如果函数A内部调用了函数B，，那么在A的调用帧上方，就会形成一个B的调用帧，等B运行结束，将结果返回到A，B的调用帧才会消失。

**尾调用优化**：只保留内存函数的调用帧，即 在A调用B时，只保留B的调用帧。

注：只有不再用到外层函数的内部变量，才能进行“尾调用优化”。

**尾递归**：尾调用自身。
递归需要同时保持多个调用帧，很容易发生“栈溢出”，对于尾递归，只存在一个调用栈，就不会发生“栈溢出”。

注：只有开启严格模式，尾调用优化才会生效。