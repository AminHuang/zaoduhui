#[ES 6标准入门(第二版)](http://es6.ruanyifeng.com/)
#写在开始 [@茗小铭](https://github.com/veronicaHu)
书山有路勤为径，学海无涯苦作舟。

在没有一定基础的情况下，去寻找快速上手的捷径简直就是作死，我还是默默的一页一页的学习吧。

#2.let和const命令
###let

|     | var  | let|
|--------- | --------  | --------|
|作用域  | 声明的函数内  |  声明的代码块内|
|变量提升  | 编译后，提升至函数顶部  |  不提升，必须声明后使用|
|死区  |      |  代码块内变量不受外部影响|
|重复定义  | 可以重复定义  |  不允许重复定义|

###const
const用来声明常量，一旦声明，不能修改。

|   |   |
|--------- | --------  |
|声明|声明的同时必须赋值|
|作用域|和let相同，只在声明的代码块内有效|
|变量提升| 不提升，只能在声明后使用|
|死区| 代码块内变量不受外部影响|
|重复定义|不能重复定义|

###全局对象
var，function 声明的全局变量依然是全局对象的属性；
let，const，class声明的全局变量不属于全局对象的属性；

#3.变量的解构赋值
解构：按照一定模式，从数字和对象中提取值，对变量进行赋值。

|等号左边|等号右边|
| --------- | --------  |
|可以设置默认值|本身或转为对象后具备Iterator接口|
|模式结构与右边不同时，会报错|   |
|模式可与右边完全匹配，或是右边的子集|   |
|模式与右边不匹配时返回undefined|   |
|let,const变量，不能重复声明|   |

|数组|对象|
| --------- | --------  |
|变量的值由位置决定|变量的值由属性名决定|

#4.字符串扩展
###Unicode表示法

|形式|例子|范围|
| --------- | --------  | -------- |
|\u + 码点|\u0061|限于\u0000-\uFFFF|
|\u + '{' + 码点 + '}'|\u{0061}|> \u0000|

###codePointAt() 

|   |   |
| :--------  | :-------- |
|charCodeAt()|只能正确处理2个字节的字符，4个字节的字符只能分别返回前两个字节和后两个字节|
|codePointAt()|可以正确处理4个字节的字符|

###String.formCodePoint()

|   |   |
| :--------  | :-------- |
|String.formCharCode()|返回码点对应的字符，大于0xFFFF时会舍弃最高位，不能正确返回|
|String.formCodePoint()|可以正确返回大于0xFFFF的字符|

###遍历器接口
ES6为字符串添加了遍历器接口，是字符串可以使用for...of,可以正确识别大于0xFFFF的码点

###at()

|   |   |
| :--------  | :-------- |
|charAt()|返回指定位置的字符，不能识别大于0xFFFF的字符|
|at()|可以正确返回大于0xFFFF的字符|

###normalize()
用于将字符的不同表示方法统一为同样的形式，称为Unicode正规化。
normalize()可以接受4个参数：
 * NFC：标准等价合成，默认参数，返回多个简单字符的合成字符。
 * NFD：标准等价分解，返回合成字符分解出的多个简单字符。
 * NFKC：兼容等价合成，返回语义上等价，视觉上不等价的合成字符。
 * NFKD：兼容等价分解，在兼容等价的前提下，返回合成字符分解出的多个简单字符。
 
###includes(),startsWith(),endsWith()
 * includes()：返回布尔值，表示是否找到了参数字符串。
 * startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
 * endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
 
###repeat()
返回一个将参数重复N次后的新字符串。

###padStart(),padEnd()
 * padStart()：在字符串头部补全，使字符串达到指定长度
 * padEnd()：在字符串尾部补全，使字符串达到指定长度

###模板字符串
 * 模板字符串会保留字符串中的空格和缩进
 * 嵌入变量时，使用${}，大括号内的值会转为字符串，对象会默认调用toString方法。

###模板编译

###标签模板
###String.raw()

#5.正则扩展
###RegExp构造函数
 * ES5：RegExp只接受字符串参数
 * ES6：RegExp还可以接受正则表达式参数，返回一个原正则表达式的拷贝。
    第2个参数指定修饰符，则返回的正则表达式会忽略原表达式中的修饰符，使用新指定的修饰符。
    
###字符串的正则方法
 * math()
 * replace()
 * search()
 * split()
 ES6将这四个方法定义在了RegExp对象上。
 
###u修饰符
Unicode模式，用于处理大于/uFFFF的Unicode字符。
 * 点字符 除换行符意外的任意单个字符，大于0xFFFF的字符必须加上u修饰符
 * Unicode字符表示法 用{}表示的Unicode字符，在正则表达式中必须加上u修饰符才能识别
 * 量词 使用u修饰符后，所有量词都可以正确识别大于0xFFFF的字符。
 * 预定义模式 \S 匹配所有不是空格的字符，只有加了u修饰符，才能正确匹配大于0xFFFF的字符。
 * i修饰符 字形相近，编码不同的Unicode字符，不加u修饰符，就无法识别非规范的字符。
 
###y修饰符
粘连修饰符
全局匹配，后一次匹配从上一次匹配成功的下一位置开始

|   |   |
| :--------  | :-------- |
|g修饰符|只要剩余位置中存在匹配就可以|
|y修饰符|匹配必须从剩余的第一个位置开始|

###sticky属性
表示是否设置了y修饰符

###flags属性
返回正则表达式的修饰符

#6.数值扩展

###二进制和八进制表示法
 * 二进制前缀0b/0N
 * 八进制前缀0o/0o
 
###Number.isFinite(),Number.isNaN()
 * Number.isFinite() 检查一个数值是否非无穷
 * Number.isNaN() 检查一个值是否为NaN
 
###Number.parerInt(),Number.parseFloat()
ES6将全局方法parserInt()和parseFloat()移植到了Number对象上，行为保持不变。

###Number.isInteger()
判断一个值是否为整数。

**注**：3和3.0被视为同一值，都为整数。

###Number.EPSILON
最小常量，用于为浮点数计算设置一个误差范围。

###安全整数和Number.isSafeInteger()
安全整数：在-2^{53}到2^{53}内的整数。

**注**：在验证运算结果时，需要同时验证参与运算的没一个值。

###Math对象的扩展
 * Math.trunc() 去除一个数的小数部分，返回整数部分
 * Math.sign() 判断一个数是正数（+1），负数（-1），还是零（0/-0）
 * Math.cbrt() 计算一个数的立方根
 * Math.clz32() 方法一个数的32位无符号整数形式有多少的前导0
 * Math.imul()　返回两个数以32位带符号整数形式相乘的结果，也是一个32位带符号整数
 * Math.fround() 返回一个数的单精度浮点数形式
 * Math.hypot() 方法所有参数的平方和的平方根
 * 对数方法
	* Math.expm1() 返回e^x-1
	* Math.log1p() 返回ln(1+x)
	* Math.log10() 返回以10为底的x的对数
	* Math.log2() 返回以2为底的x的对数

###指数运算符 
2 ** 2 = 4

#7.数组扩展
###Array.from()
将类似数组的对象和可遍历对象转换为数组。

###Array.of()
将一组数组转换为数组。

###数组实例的copyWithin()
将当前数组内指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。
Array.prototype.copyWithin(target, start = 0, end = this.length)
 * target(必须)：从该位置开始替换数据。
 * start（可选）：从给位置开始读取数据，默认为0。如果为负值，表示倒数。
 * end(可选)：到该位置停止读取数据，默认等于数组长度。如果为负值，表示倒数。

###数组实例的find()和findIndex()

|   |   |
| :--------  | :-------- |
|find|返回第一个符合条件的数组成员，否则返回undefined|
|findIndex|返回第一个符合条件的数组成员的位置，否则返回-1|

###数组实例的fill()
使用指定值在指定位置填充数组。

###数组实例的entries()、keys()和values()
 * entries() 对键值对的遍历
 * keys() 对键名的遍历
 * values() 对键值的遍历

###数组实例的includes()
返回数组是否包含指定的值true/false。

###数组的空位
ES6会将数组的空位转换为undefined。



#8.函数的扩展
###函数参数的默认值
 * 可以与解构赋值默认值结合使用
 * 定义了默认值的参数一般是函数的尾参数
 * 定义了默认值后，函数的length属性将返回没有指定默认值的参数个数
 * 作用域
 	* 如果参数默认值是一个变量，则该变量所在的作用域先是当前函数的作用域，然后才是全局作用域
 	* 如果参数的默认值是一个函数B，则函数B的作用域是全局作用域

###rest参数
以“···变量名”的形式，将函数的多余参数放入一个名为变量名的数组中。
 * rest参数只能作为函数的最后一个参数
 * 函数的length属性不包括rest参数
 
###扩展运算符
相当于rest参数的逆运算，将一个数值转为用逗号分隔的参数序列。
 * 可以替代数组的apply方法
 * 可以用来合并数组
 * 与解构赋值结合可以用来生成数组
 * 使函数可以返回多个值
 * 可用来将字符串和类数组的对象转为数组
 
###name属性
函数的name属性返回该函数的函数名。

###箭头函数
ES6可以用箭头（=>）定义函数。

|箭头左边|箭头右边|
| ------- | ------- |
|用圆括号包裹参数|用大括号包裹多余一行的代码|
|一个参数可以省略圆括号|一行代码可以省略大括号|

需要注意的地方：
 * 箭头函数体内没有自己的this，调用的是定义时所在对象的this
 * 不可以当作构造函数，也就是不能使用new 命令
 * 不可以使用arguments对象，可以使用rest参数代替
 * 不可以使用yield命令，因此箭头函数不能用作Generator函数
 
### 函数绑定
形式：对象::函数
将左边的对象作为上下文环境（this）绑定到右边的函数上

###尾调用优化

 * 尾调用：某个函数的最后一步是调用另一个函数
 * 调用帧：函数调用会在内存形成以个“调用记录”，用来保存调用位置和内部变量等信息。
 * 调用栈：所有的调用帧形成以个调用栈。

如果函数A内部调用了函数B，，那么在A的调用帧上方，就会形成一个B的调用帧，等B运行结束，将结果返回到A，B的调用帧才会消失。

**尾调用优化**：只保留内存函数的调用帧，即 在A调用B时，只保留B的调用帧。

注：只有不再用到外层函数的内部变量，才能进行“尾调用优化”。

**尾递归**：尾调用自身。
递归需要同时保持多个调用帧，很容易发生“栈溢出”，对于尾递归，只存在一个调用栈，就不会发生“栈溢出”。

注：只有开启严格模式，尾调用优化才会生效。

#9.对象的扩展

###属性的简洁表示法
声明对象时，只写属性名，不写属性值，属性值等于属性名所代表的变量。

###属性名表达式
|形式|例子|
| ----- | ----- |
|.|obj.foo = true;|
|[]|obj['a'+'bc'] = 123;|
|字面量|var obj = { foo： true;}|
|属性名表达式|var obj = { ['a'+'cc']: 123, \['h'+'ello'\] () {console.log('hello')}}|

注：属性名表达式与简洁表示法不能同时使用。

###方法的name属性
